// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: as_c_proto.proto

#ifndef PROTOBUF_as_5fc_5fproto_2eproto__INCLUDED
#define PROTOBUF_as_5fc_5fproto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

class c_as_register_req;
class as_c_register_res;
class c_as_login_req;
class area;
class area_list;
class as_c_login_res;
class c_as_login_if_no_register_req;
class as_c_login_if_no_register_res;
class c_as_enter_area_req;
class as_c_enter_area_res;
class c_as_logout_req;
class as_c_logout_res;

enum area_EAreaStatus {
  area_EAreaStatus_EAreaStatus_None = 0,
  area_EAreaStatus_EAreaStatus_Good = 1,
  area_EAreaStatus_EAreaStatus_Normal = 2,
  area_EAreaStatus_EAreaStatus_Bad = 3,
  area_EAreaStatus_EAreaStatus_New = 4
};
bool area_EAreaStatus_IsValid(int value);
const area_EAreaStatus area_EAreaStatus_EAreaStatus_MIN = area_EAreaStatus_EAreaStatus_None;
const area_EAreaStatus area_EAreaStatus_EAreaStatus_MAX = area_EAreaStatus_EAreaStatus_New;
const int area_EAreaStatus_EAreaStatus_ARRAYSIZE = area_EAreaStatus_EAreaStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* area_EAreaStatus_descriptor();
inline const ::std::string& area_EAreaStatus_Name(area_EAreaStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    area_EAreaStatus_descriptor(), value);
}
inline bool area_EAreaStatus_Parse(
    const ::std::string& name, area_EAreaStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<area_EAreaStatus>(
    area_EAreaStatus_descriptor(), name, value);
}
enum e_asc_proto_version {
  ASC_VERSION = 1
};
bool e_asc_proto_version_IsValid(int value);
const e_asc_proto_version e_asc_proto_version_MIN = ASC_VERSION;
const e_asc_proto_version e_asc_proto_version_MAX = ASC_VERSION;
const int e_asc_proto_version_ARRAYSIZE = e_asc_proto_version_MAX + 1;

const ::google::protobuf::EnumDescriptor* e_asc_proto_version_descriptor();
inline const ::std::string& e_asc_proto_version_Name(e_asc_proto_version value) {
  return ::google::protobuf::internal::NameOfEnum(
    e_asc_proto_version_descriptor(), value);
}
inline bool e_asc_proto_version_Parse(
    const ::std::string& name, e_asc_proto_version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<e_asc_proto_version>(
    e_asc_proto_version_descriptor(), name, value);
}
enum e_msg_c_as {
  e_msg_c_as_min = 0,
  e_msg_c_as_register_req = 1,
  e_msg_c_as_login_req = 2,
  e_msg_c_as_enter_area_req = 3,
  e_msg_c_as_logout_req = 4,
  e_msg_c_as_login_if_no_register_req = 5,
  e_msg_c_as_max = 6
};
bool e_msg_c_as_IsValid(int value);
const e_msg_c_as e_msg_c_as_MIN = e_msg_c_as_min;
const e_msg_c_as e_msg_c_as_MAX = e_msg_c_as_max;
const int e_msg_c_as_ARRAYSIZE = e_msg_c_as_MAX + 1;

const ::google::protobuf::EnumDescriptor* e_msg_c_as_descriptor();
inline const ::std::string& e_msg_c_as_Name(e_msg_c_as value) {
  return ::google::protobuf::internal::NameOfEnum(
    e_msg_c_as_descriptor(), value);
}
inline bool e_msg_c_as_Parse(
    const ::std::string& name, e_msg_c_as* value) {
  return ::google::protobuf::internal::ParseNamedEnum<e_msg_c_as>(
    e_msg_c_as_descriptor(), name, value);
}
enum e_msg_as_c {
  e_msg_as_c_min = 0,
  e_msg_as_c_register_res = 1,
  e_msg_as_c_login_res = 2,
  e_msg_as_c_enter_area_res = 3,
  e_msg_as_c_logout_res = 4,
  e_msg_as_c_login_if_no_register_res = 5,
  e_msg_as_c_max = 6
};
bool e_msg_as_c_IsValid(int value);
const e_msg_as_c e_msg_as_c_MIN = e_msg_as_c_min;
const e_msg_as_c e_msg_as_c_MAX = e_msg_as_c_max;
const int e_msg_as_c_ARRAYSIZE = e_msg_as_c_MAX + 1;

const ::google::protobuf::EnumDescriptor* e_msg_as_c_descriptor();
inline const ::std::string& e_msg_as_c_Name(e_msg_as_c value) {
  return ::google::protobuf::internal::NameOfEnum(
    e_msg_as_c_descriptor(), value);
}
inline bool e_msg_as_c_Parse(
    const ::std::string& name, e_msg_as_c* value) {
  return ::google::protobuf::internal::ParseNamedEnum<e_msg_as_c>(
    e_msg_as_c_descriptor(), name, value);
}
enum e_asc_errorcode {
  e_asc_errorcode_min = 0,
  e_asc_errorcode_success = 1,
  e_asc_errorcode_unkown_error = 2,
  e_asc_errorcode_registe_already = 3,
  e_asc_errorcode_account_not_exist_or_wrong_password = 4,
  e_asc_errorcode_not_logined = 5,
  e_asc_errorcode_no_this_area = 6,
  e_asc_errorcode_area_closed = 7,
  e_asc_errorcode_wrong_password = 8,
  e_asc_errorcode_max = 9
};
bool e_asc_errorcode_IsValid(int value);
const e_asc_errorcode e_asc_errorcode_MIN = e_asc_errorcode_min;
const e_asc_errorcode e_asc_errorcode_MAX = e_asc_errorcode_max;
const int e_asc_errorcode_ARRAYSIZE = e_asc_errorcode_MAX + 1;

const ::google::protobuf::EnumDescriptor* e_asc_errorcode_descriptor();
inline const ::std::string& e_asc_errorcode_Name(e_asc_errorcode value) {
  return ::google::protobuf::internal::NameOfEnum(
    e_asc_errorcode_descriptor(), value);
}
inline bool e_asc_errorcode_Parse(
    const ::std::string& name, e_asc_errorcode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<e_asc_errorcode>(
    e_asc_errorcode_descriptor(), name, value);
}
// ===================================================================

class c_as_register_req : public ::google::protobuf::Message {
 public:
  c_as_register_req();
  virtual ~c_as_register_req();

  c_as_register_req(const c_as_register_req& from);

  inline c_as_register_req& operator=(const c_as_register_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const c_as_register_req& default_instance();

  void Swap(c_as_register_req* other);

  // implements Message ----------------------------------------------

  c_as_register_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const c_as_register_req& from);
  void MergeFrom(const c_as_register_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 plantform_id = 1;
  inline bool has_plantform_id() const;
  inline void clear_plantform_id();
  static const int kPlantformIdFieldNumber = 1;
  inline ::google::protobuf::int32 plantform_id() const;
  inline void set_plantform_id(::google::protobuf::int32 value);

  // required int32 plantform_sub_id = 2;
  inline bool has_plantform_sub_id() const;
  inline void clear_plantform_sub_id();
  static const int kPlantformSubIdFieldNumber = 2;
  inline ::google::protobuf::int32 plantform_sub_id() const;
  inline void set_plantform_sub_id(::google::protobuf::int32 value);

  // required string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:c_as_register_req)
 private:
  inline void set_has_plantform_id();
  inline void clear_has_plantform_id();
  inline void set_has_plantform_sub_id();
  inline void clear_has_plantform_sub_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 plantform_id_;
  ::google::protobuf::int32 plantform_sub_id_;
  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static c_as_register_req* default_instance_;
};
// -------------------------------------------------------------------

class as_c_register_res : public ::google::protobuf::Message {
 public:
  as_c_register_res();
  virtual ~as_c_register_res();

  as_c_register_res(const as_c_register_res& from);

  inline as_c_register_res& operator=(const as_c_register_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const as_c_register_res& default_instance();

  void Swap(as_c_register_res* other);

  // implements Message ----------------------------------------------

  as_c_register_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const as_c_register_res& from);
  void MergeFrom(const as_c_register_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:as_c_register_res)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static as_c_register_res* default_instance_;
};
// -------------------------------------------------------------------

class c_as_login_req : public ::google::protobuf::Message {
 public:
  c_as_login_req();
  virtual ~c_as_login_req();

  c_as_login_req(const c_as_login_req& from);

  inline c_as_login_req& operator=(const c_as_login_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const c_as_login_req& default_instance();

  void Swap(c_as_login_req* other);

  // implements Message ----------------------------------------------

  c_as_login_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const c_as_login_req& from);
  void MergeFrom(const c_as_login_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 plantform_id = 1;
  inline bool has_plantform_id() const;
  inline void clear_plantform_id();
  static const int kPlantformIdFieldNumber = 1;
  inline ::google::protobuf::int32 plantform_id() const;
  inline void set_plantform_id(::google::protobuf::int32 value);

  // required int32 plantform_sub_id = 2;
  inline bool has_plantform_sub_id() const;
  inline void clear_plantform_sub_id();
  static const int kPlantformSubIdFieldNumber = 2;
  inline ::google::protobuf::int32 plantform_sub_id() const;
  inline void set_plantform_sub_id(::google::protobuf::int32 value);

  // required string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:c_as_login_req)
 private:
  inline void set_has_plantform_id();
  inline void clear_has_plantform_id();
  inline void set_has_plantform_sub_id();
  inline void clear_has_plantform_sub_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 plantform_id_;
  ::google::protobuf::int32 plantform_sub_id_;
  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static c_as_login_req* default_instance_;
};
// -------------------------------------------------------------------

class area : public ::google::protobuf::Message {
 public:
  area();
  virtual ~area();

  area(const area& from);

  inline area& operator=(const area& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area& default_instance();

  void Swap(area* other);

  // implements Message ----------------------------------------------

  area* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area& from);
  void MergeFrom(const area& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef area_EAreaStatus EAreaStatus;
  static const EAreaStatus EAreaStatus_None = area_EAreaStatus_EAreaStatus_None;
  static const EAreaStatus EAreaStatus_Good = area_EAreaStatus_EAreaStatus_Good;
  static const EAreaStatus EAreaStatus_Normal = area_EAreaStatus_EAreaStatus_Normal;
  static const EAreaStatus EAreaStatus_Bad = area_EAreaStatus_EAreaStatus_Bad;
  static const EAreaStatus EAreaStatus_New = area_EAreaStatus_EAreaStatus_New;
  static inline bool EAreaStatus_IsValid(int value) {
    return area_EAreaStatus_IsValid(value);
  }
  static const EAreaStatus EAreaStatus_MIN =
    area_EAreaStatus_EAreaStatus_MIN;
  static const EAreaStatus EAreaStatus_MAX =
    area_EAreaStatus_EAreaStatus_MAX;
  static const int EAreaStatus_ARRAYSIZE =
    area_EAreaStatus_EAreaStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EAreaStatus_descriptor() {
    return area_EAreaStatus_descriptor();
  }
  static inline const ::std::string& EAreaStatus_Name(EAreaStatus value) {
    return area_EAreaStatus_Name(value);
  }
  static inline bool EAreaStatus_Parse(const ::std::string& name,
      EAreaStatus* value) {
    return area_EAreaStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 area_id = 1;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 1;
  inline ::google::protobuf::int32 area_id() const;
  inline void set_area_id(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:area)
 private:
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 area_id_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static area* default_instance_;
};
// -------------------------------------------------------------------

class area_list : public ::google::protobuf::Message {
 public:
  area_list();
  virtual ~area_list();

  area_list(const area_list& from);

  inline area_list& operator=(const area_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_list& default_instance();

  void Swap(area_list* other);

  // implements Message ----------------------------------------------

  area_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_list& from);
  void MergeFrom(const area_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .area areas = 1;
  inline int areas_size() const;
  inline void clear_areas();
  static const int kAreasFieldNumber = 1;
  inline const ::area& areas(int index) const;
  inline ::area* mutable_areas(int index);
  inline ::area* add_areas();
  inline const ::google::protobuf::RepeatedPtrField< ::area >&
      areas() const;
  inline ::google::protobuf::RepeatedPtrField< ::area >*
      mutable_areas();

  // @@protoc_insertion_point(class_scope:area_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::area > areas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static area_list* default_instance_;
};
// -------------------------------------------------------------------

class as_c_login_res : public ::google::protobuf::Message {
 public:
  as_c_login_res();
  virtual ~as_c_login_res();

  as_c_login_res(const as_c_login_res& from);

  inline as_c_login_res& operator=(const as_c_login_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const as_c_login_res& default_instance();

  void Swap(as_c_login_res* other);

  // implements Message ----------------------------------------------

  as_c_login_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const as_c_login_res& from);
  void MergeFrom(const as_c_login_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // optional .area_list areas = 3;
  inline bool has_areas() const;
  inline void clear_areas();
  static const int kAreasFieldNumber = 3;
  inline const ::area_list& areas() const;
  inline ::area_list* mutable_areas();
  inline ::area_list* release_areas();
  inline void set_allocated_areas(::area_list* areas);

  // @@protoc_insertion_point(class_scope:as_c_login_res)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_areas();
  inline void clear_has_areas();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::area_list* areas_;
  ::google::protobuf::int32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static as_c_login_res* default_instance_;
};
// -------------------------------------------------------------------

class c_as_login_if_no_register_req : public ::google::protobuf::Message {
 public:
  c_as_login_if_no_register_req();
  virtual ~c_as_login_if_no_register_req();

  c_as_login_if_no_register_req(const c_as_login_if_no_register_req& from);

  inline c_as_login_if_no_register_req& operator=(const c_as_login_if_no_register_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const c_as_login_if_no_register_req& default_instance();

  void Swap(c_as_login_if_no_register_req* other);

  // implements Message ----------------------------------------------

  c_as_login_if_no_register_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const c_as_login_if_no_register_req& from);
  void MergeFrom(const c_as_login_if_no_register_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 plantform_id = 1;
  inline bool has_plantform_id() const;
  inline void clear_plantform_id();
  static const int kPlantformIdFieldNumber = 1;
  inline ::google::protobuf::int32 plantform_id() const;
  inline void set_plantform_id(::google::protobuf::int32 value);

  // required int32 plantform_sub_id = 2;
  inline bool has_plantform_sub_id() const;
  inline void clear_plantform_sub_id();
  static const int kPlantformSubIdFieldNumber = 2;
  inline ::google::protobuf::int32 plantform_sub_id() const;
  inline void set_plantform_sub_id(::google::protobuf::int32 value);

  // required string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:c_as_login_if_no_register_req)
 private:
  inline void set_has_plantform_id();
  inline void clear_has_plantform_id();
  inline void set_has_plantform_sub_id();
  inline void clear_has_plantform_sub_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 plantform_id_;
  ::google::protobuf::int32 plantform_sub_id_;
  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static c_as_login_if_no_register_req* default_instance_;
};
// -------------------------------------------------------------------

class as_c_login_if_no_register_res : public ::google::protobuf::Message {
 public:
  as_c_login_if_no_register_res();
  virtual ~as_c_login_if_no_register_res();

  as_c_login_if_no_register_res(const as_c_login_if_no_register_res& from);

  inline as_c_login_if_no_register_res& operator=(const as_c_login_if_no_register_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const as_c_login_if_no_register_res& default_instance();

  void Swap(as_c_login_if_no_register_res* other);

  // implements Message ----------------------------------------------

  as_c_login_if_no_register_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const as_c_login_if_no_register_res& from);
  void MergeFrom(const as_c_login_if_no_register_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // optional .area_list areas = 2;
  inline bool has_areas() const;
  inline void clear_areas();
  static const int kAreasFieldNumber = 2;
  inline const ::area_list& areas() const;
  inline ::area_list* mutable_areas();
  inline ::area_list* release_areas();
  inline void set_allocated_areas(::area_list* areas);

  // @@protoc_insertion_point(class_scope:as_c_login_if_no_register_res)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_areas();
  inline void clear_has_areas();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::area_list* areas_;
  ::google::protobuf::int32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static as_c_login_if_no_register_res* default_instance_;
};
// -------------------------------------------------------------------

class c_as_enter_area_req : public ::google::protobuf::Message {
 public:
  c_as_enter_area_req();
  virtual ~c_as_enter_area_req();

  c_as_enter_area_req(const c_as_enter_area_req& from);

  inline c_as_enter_area_req& operator=(const c_as_enter_area_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const c_as_enter_area_req& default_instance();

  void Swap(c_as_enter_area_req* other);

  // implements Message ----------------------------------------------

  c_as_enter_area_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const c_as_enter_area_req& from);
  void MergeFrom(const c_as_enter_area_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 area_id = 1;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 1;
  inline ::google::protobuf::int32 area_id() const;
  inline void set_area_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:c_as_enter_area_req)
 private:
  inline void set_has_area_id();
  inline void clear_has_area_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 area_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static c_as_enter_area_req* default_instance_;
};
// -------------------------------------------------------------------

class as_c_enter_area_res : public ::google::protobuf::Message {
 public:
  as_c_enter_area_res();
  virtual ~as_c_enter_area_res();

  as_c_enter_area_res(const as_c_enter_area_res& from);

  inline as_c_enter_area_res& operator=(const as_c_enter_area_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const as_c_enter_area_res& default_instance();

  void Swap(as_c_enter_area_res* other);

  // implements Message ----------------------------------------------

  as_c_enter_area_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const as_c_enter_area_res& from);
  void MergeFrom(const as_c_enter_area_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional bytes token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:as_c_enter_area_res)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::int32 error_code_;
  ::google::protobuf::int32 port_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static as_c_enter_area_res* default_instance_;
};
// -------------------------------------------------------------------

class c_as_logout_req : public ::google::protobuf::Message {
 public:
  c_as_logout_req();
  virtual ~c_as_logout_req();

  c_as_logout_req(const c_as_logout_req& from);

  inline c_as_logout_req& operator=(const c_as_logout_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const c_as_logout_req& default_instance();

  void Swap(c_as_logout_req* other);

  // implements Message ----------------------------------------------

  c_as_logout_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const c_as_logout_req& from);
  void MergeFrom(const c_as_logout_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 plantform_id = 1;
  inline bool has_plantform_id() const;
  inline void clear_plantform_id();
  static const int kPlantformIdFieldNumber = 1;
  inline ::google::protobuf::int32 plantform_id() const;
  inline void set_plantform_id(::google::protobuf::int32 value);

  // required int32 plantform_sub_id = 2;
  inline bool has_plantform_sub_id() const;
  inline void clear_plantform_sub_id();
  static const int kPlantformSubIdFieldNumber = 2;
  inline ::google::protobuf::int32 plantform_sub_id() const;
  inline void set_plantform_sub_id(::google::protobuf::int32 value);

  // required string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:c_as_logout_req)
 private:
  inline void set_has_plantform_id();
  inline void clear_has_plantform_id();
  inline void set_has_plantform_sub_id();
  inline void clear_has_plantform_sub_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 plantform_id_;
  ::google::protobuf::int32 plantform_sub_id_;
  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static c_as_logout_req* default_instance_;
};
// -------------------------------------------------------------------

class as_c_logout_res : public ::google::protobuf::Message {
 public:
  as_c_logout_res();
  virtual ~as_c_logout_res();

  as_c_logout_res(const as_c_logout_res& from);

  inline as_c_logout_res& operator=(const as_c_logout_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const as_c_logout_res& default_instance();

  void Swap(as_c_logout_res* other);

  // implements Message ----------------------------------------------

  as_c_logout_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const as_c_logout_res& from);
  void MergeFrom(const as_c_logout_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:as_c_logout_res)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_AssignDesc_as_5fc_5fproto_2eproto();
  friend void protobuf_ShutdownFile_as_5fc_5fproto_2eproto();

  void InitAsDefaultInstance();
  static as_c_logout_res* default_instance_;
};
// ===================================================================


// ===================================================================

// c_as_register_req

// required int32 plantform_id = 1;
inline bool c_as_register_req::has_plantform_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void c_as_register_req::set_has_plantform_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void c_as_register_req::clear_has_plantform_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void c_as_register_req::clear_plantform_id() {
  plantform_id_ = 0;
  clear_has_plantform_id();
}
inline ::google::protobuf::int32 c_as_register_req::plantform_id() const {
  return plantform_id_;
}
inline void c_as_register_req::set_plantform_id(::google::protobuf::int32 value) {
  set_has_plantform_id();
  plantform_id_ = value;
}

// required int32 plantform_sub_id = 2;
inline bool c_as_register_req::has_plantform_sub_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void c_as_register_req::set_has_plantform_sub_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void c_as_register_req::clear_has_plantform_sub_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void c_as_register_req::clear_plantform_sub_id() {
  plantform_sub_id_ = 0;
  clear_has_plantform_sub_id();
}
inline ::google::protobuf::int32 c_as_register_req::plantform_sub_id() const {
  return plantform_sub_id_;
}
inline void c_as_register_req::set_plantform_sub_id(::google::protobuf::int32 value) {
  set_has_plantform_sub_id();
  plantform_sub_id_ = value;
}

// required string account = 3;
inline bool c_as_register_req::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void c_as_register_req::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void c_as_register_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void c_as_register_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& c_as_register_req::account() const {
  return *account_;
}
inline void c_as_register_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void c_as_register_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void c_as_register_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c_as_register_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* c_as_register_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c_as_register_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 4;
inline bool c_as_register_req::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void c_as_register_req::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void c_as_register_req::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void c_as_register_req::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& c_as_register_req::password() const {
  return *password_;
}
inline void c_as_register_req::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void c_as_register_req::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void c_as_register_req::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c_as_register_req::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* c_as_register_req::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c_as_register_req::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// as_c_register_res

// required int32 error_code = 1;
inline bool as_c_register_res::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void as_c_register_res::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void as_c_register_res::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void as_c_register_res::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 as_c_register_res::error_code() const {
  return error_code_;
}
inline void as_c_register_res::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// c_as_login_req

// required int32 plantform_id = 1;
inline bool c_as_login_req::has_plantform_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void c_as_login_req::set_has_plantform_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void c_as_login_req::clear_has_plantform_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void c_as_login_req::clear_plantform_id() {
  plantform_id_ = 0;
  clear_has_plantform_id();
}
inline ::google::protobuf::int32 c_as_login_req::plantform_id() const {
  return plantform_id_;
}
inline void c_as_login_req::set_plantform_id(::google::protobuf::int32 value) {
  set_has_plantform_id();
  plantform_id_ = value;
}

// required int32 plantform_sub_id = 2;
inline bool c_as_login_req::has_plantform_sub_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void c_as_login_req::set_has_plantform_sub_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void c_as_login_req::clear_has_plantform_sub_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void c_as_login_req::clear_plantform_sub_id() {
  plantform_sub_id_ = 0;
  clear_has_plantform_sub_id();
}
inline ::google::protobuf::int32 c_as_login_req::plantform_sub_id() const {
  return plantform_sub_id_;
}
inline void c_as_login_req::set_plantform_sub_id(::google::protobuf::int32 value) {
  set_has_plantform_sub_id();
  plantform_sub_id_ = value;
}

// required string account = 3;
inline bool c_as_login_req::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void c_as_login_req::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void c_as_login_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void c_as_login_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& c_as_login_req::account() const {
  return *account_;
}
inline void c_as_login_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void c_as_login_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void c_as_login_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c_as_login_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* c_as_login_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c_as_login_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 4;
inline bool c_as_login_req::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void c_as_login_req::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void c_as_login_req::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void c_as_login_req::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& c_as_login_req::password() const {
  return *password_;
}
inline void c_as_login_req::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void c_as_login_req::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void c_as_login_req::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c_as_login_req::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* c_as_login_req::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c_as_login_req::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// area

// required int32 area_id = 1;
inline bool area::has_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area::set_has_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area::clear_area_id() {
  area_id_ = 0;
  clear_has_area_id();
}
inline ::google::protobuf::int32 area::area_id() const {
  return area_id_;
}
inline void area::set_area_id(::google::protobuf::int32 value) {
  set_has_area_id();
  area_id_ = value;
}

// required string name = 2;
inline bool area::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& area::name() const {
  return *name_;
}
inline void area::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void area::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void area::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* area::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* area::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void area::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 status = 3;
inline bool area::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void area::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void area::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void area::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 area::status() const {
  return status_;
}
inline void area::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// area_list

// repeated .area areas = 1;
inline int area_list::areas_size() const {
  return areas_.size();
}
inline void area_list::clear_areas() {
  areas_.Clear();
}
inline const ::area& area_list::areas(int index) const {
  return areas_.Get(index);
}
inline ::area* area_list::mutable_areas(int index) {
  return areas_.Mutable(index);
}
inline ::area* area_list::add_areas() {
  return areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::area >&
area_list::areas() const {
  return areas_;
}
inline ::google::protobuf::RepeatedPtrField< ::area >*
area_list::mutable_areas() {
  return &areas_;
}

// -------------------------------------------------------------------

// as_c_login_res

// required int32 error_code = 1;
inline bool as_c_login_res::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void as_c_login_res::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void as_c_login_res::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void as_c_login_res::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 as_c_login_res::error_code() const {
  return error_code_;
}
inline void as_c_login_res::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional .area_list areas = 3;
inline bool as_c_login_res::has_areas() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void as_c_login_res::set_has_areas() {
  _has_bits_[0] |= 0x00000002u;
}
inline void as_c_login_res::clear_has_areas() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void as_c_login_res::clear_areas() {
  if (areas_ != NULL) areas_->::area_list::Clear();
  clear_has_areas();
}
inline const ::area_list& as_c_login_res::areas() const {
  return areas_ != NULL ? *areas_ : *default_instance_->areas_;
}
inline ::area_list* as_c_login_res::mutable_areas() {
  set_has_areas();
  if (areas_ == NULL) areas_ = new ::area_list;
  return areas_;
}
inline ::area_list* as_c_login_res::release_areas() {
  clear_has_areas();
  ::area_list* temp = areas_;
  areas_ = NULL;
  return temp;
}
inline void as_c_login_res::set_allocated_areas(::area_list* areas) {
  delete areas_;
  areas_ = areas;
  if (areas) {
    set_has_areas();
  } else {
    clear_has_areas();
  }
}

// -------------------------------------------------------------------

// c_as_login_if_no_register_req

// required int32 plantform_id = 1;
inline bool c_as_login_if_no_register_req::has_plantform_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void c_as_login_if_no_register_req::set_has_plantform_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void c_as_login_if_no_register_req::clear_has_plantform_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void c_as_login_if_no_register_req::clear_plantform_id() {
  plantform_id_ = 0;
  clear_has_plantform_id();
}
inline ::google::protobuf::int32 c_as_login_if_no_register_req::plantform_id() const {
  return plantform_id_;
}
inline void c_as_login_if_no_register_req::set_plantform_id(::google::protobuf::int32 value) {
  set_has_plantform_id();
  plantform_id_ = value;
}

// required int32 plantform_sub_id = 2;
inline bool c_as_login_if_no_register_req::has_plantform_sub_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void c_as_login_if_no_register_req::set_has_plantform_sub_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void c_as_login_if_no_register_req::clear_has_plantform_sub_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void c_as_login_if_no_register_req::clear_plantform_sub_id() {
  plantform_sub_id_ = 0;
  clear_has_plantform_sub_id();
}
inline ::google::protobuf::int32 c_as_login_if_no_register_req::plantform_sub_id() const {
  return plantform_sub_id_;
}
inline void c_as_login_if_no_register_req::set_plantform_sub_id(::google::protobuf::int32 value) {
  set_has_plantform_sub_id();
  plantform_sub_id_ = value;
}

// required string account = 3;
inline bool c_as_login_if_no_register_req::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void c_as_login_if_no_register_req::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void c_as_login_if_no_register_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void c_as_login_if_no_register_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& c_as_login_if_no_register_req::account() const {
  return *account_;
}
inline void c_as_login_if_no_register_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void c_as_login_if_no_register_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void c_as_login_if_no_register_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c_as_login_if_no_register_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* c_as_login_if_no_register_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c_as_login_if_no_register_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 4;
inline bool c_as_login_if_no_register_req::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void c_as_login_if_no_register_req::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void c_as_login_if_no_register_req::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void c_as_login_if_no_register_req::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& c_as_login_if_no_register_req::password() const {
  return *password_;
}
inline void c_as_login_if_no_register_req::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void c_as_login_if_no_register_req::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void c_as_login_if_no_register_req::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c_as_login_if_no_register_req::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* c_as_login_if_no_register_req::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c_as_login_if_no_register_req::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// as_c_login_if_no_register_res

// required int32 error_code = 1;
inline bool as_c_login_if_no_register_res::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void as_c_login_if_no_register_res::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void as_c_login_if_no_register_res::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void as_c_login_if_no_register_res::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 as_c_login_if_no_register_res::error_code() const {
  return error_code_;
}
inline void as_c_login_if_no_register_res::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional .area_list areas = 2;
inline bool as_c_login_if_no_register_res::has_areas() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void as_c_login_if_no_register_res::set_has_areas() {
  _has_bits_[0] |= 0x00000002u;
}
inline void as_c_login_if_no_register_res::clear_has_areas() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void as_c_login_if_no_register_res::clear_areas() {
  if (areas_ != NULL) areas_->::area_list::Clear();
  clear_has_areas();
}
inline const ::area_list& as_c_login_if_no_register_res::areas() const {
  return areas_ != NULL ? *areas_ : *default_instance_->areas_;
}
inline ::area_list* as_c_login_if_no_register_res::mutable_areas() {
  set_has_areas();
  if (areas_ == NULL) areas_ = new ::area_list;
  return areas_;
}
inline ::area_list* as_c_login_if_no_register_res::release_areas() {
  clear_has_areas();
  ::area_list* temp = areas_;
  areas_ = NULL;
  return temp;
}
inline void as_c_login_if_no_register_res::set_allocated_areas(::area_list* areas) {
  delete areas_;
  areas_ = areas;
  if (areas) {
    set_has_areas();
  } else {
    clear_has_areas();
  }
}

// -------------------------------------------------------------------

// c_as_enter_area_req

// required int32 area_id = 1;
inline bool c_as_enter_area_req::has_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void c_as_enter_area_req::set_has_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void c_as_enter_area_req::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void c_as_enter_area_req::clear_area_id() {
  area_id_ = 0;
  clear_has_area_id();
}
inline ::google::protobuf::int32 c_as_enter_area_req::area_id() const {
  return area_id_;
}
inline void c_as_enter_area_req::set_area_id(::google::protobuf::int32 value) {
  set_has_area_id();
  area_id_ = value;
}

// -------------------------------------------------------------------

// as_c_enter_area_res

// required int32 error_code = 1;
inline bool as_c_enter_area_res::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void as_c_enter_area_res::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void as_c_enter_area_res::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void as_c_enter_area_res::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 as_c_enter_area_res::error_code() const {
  return error_code_;
}
inline void as_c_enter_area_res::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional string ip = 2;
inline bool as_c_enter_area_res::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void as_c_enter_area_res::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void as_c_enter_area_res::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void as_c_enter_area_res::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& as_c_enter_area_res::ip() const {
  return *ip_;
}
inline void as_c_enter_area_res::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void as_c_enter_area_res::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void as_c_enter_area_res::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* as_c_enter_area_res::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* as_c_enter_area_res::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void as_c_enter_area_res::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool as_c_enter_area_res::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void as_c_enter_area_res::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void as_c_enter_area_res::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void as_c_enter_area_res::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 as_c_enter_area_res::port() const {
  return port_;
}
inline void as_c_enter_area_res::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional bytes token = 4;
inline bool as_c_enter_area_res::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void as_c_enter_area_res::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void as_c_enter_area_res::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void as_c_enter_area_res::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& as_c_enter_area_res::token() const {
  return *token_;
}
inline void as_c_enter_area_res::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void as_c_enter_area_res::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void as_c_enter_area_res::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* as_c_enter_area_res::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* as_c_enter_area_res::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void as_c_enter_area_res::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// c_as_logout_req

// required int32 plantform_id = 1;
inline bool c_as_logout_req::has_plantform_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void c_as_logout_req::set_has_plantform_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void c_as_logout_req::clear_has_plantform_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void c_as_logout_req::clear_plantform_id() {
  plantform_id_ = 0;
  clear_has_plantform_id();
}
inline ::google::protobuf::int32 c_as_logout_req::plantform_id() const {
  return plantform_id_;
}
inline void c_as_logout_req::set_plantform_id(::google::protobuf::int32 value) {
  set_has_plantform_id();
  plantform_id_ = value;
}

// required int32 plantform_sub_id = 2;
inline bool c_as_logout_req::has_plantform_sub_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void c_as_logout_req::set_has_plantform_sub_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void c_as_logout_req::clear_has_plantform_sub_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void c_as_logout_req::clear_plantform_sub_id() {
  plantform_sub_id_ = 0;
  clear_has_plantform_sub_id();
}
inline ::google::protobuf::int32 c_as_logout_req::plantform_sub_id() const {
  return plantform_sub_id_;
}
inline void c_as_logout_req::set_plantform_sub_id(::google::protobuf::int32 value) {
  set_has_plantform_sub_id();
  plantform_sub_id_ = value;
}

// required string account = 3;
inline bool c_as_logout_req::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void c_as_logout_req::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void c_as_logout_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void c_as_logout_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& c_as_logout_req::account() const {
  return *account_;
}
inline void c_as_logout_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void c_as_logout_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void c_as_logout_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c_as_logout_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* c_as_logout_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c_as_logout_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 4;
inline bool c_as_logout_req::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void c_as_logout_req::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void c_as_logout_req::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void c_as_logout_req::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& c_as_logout_req::password() const {
  return *password_;
}
inline void c_as_logout_req::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void c_as_logout_req::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void c_as_logout_req::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c_as_logout_req::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* c_as_logout_req::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c_as_logout_req::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// as_c_logout_res

// optional int32 error_code = 1;
inline bool as_c_logout_res::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void as_c_logout_res::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void as_c_logout_res::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void as_c_logout_res::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 as_c_logout_res::error_code() const {
  return error_code_;
}
inline void as_c_logout_res::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::area_EAreaStatus>() {
  return ::area_EAreaStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::e_asc_proto_version>() {
  return ::e_asc_proto_version_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::e_msg_c_as>() {
  return ::e_msg_c_as_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::e_msg_as_c>() {
  return ::e_msg_as_c_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::e_asc_errorcode>() {
  return ::e_asc_errorcode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_as_5fc_5fproto_2eproto__INCLUDED
